package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43-dev

import (
	"context"
	"example/FindProMates-Api/graph/model"
	"example/FindProMates-Api/internal/app"
	"example/FindProMates-Api/internal/database/users"
	"example/FindProMates-Api/internal/pkg/jwt"
	"example/FindProMates-Api/internal/pkg/utils"
	"example/FindProMates-Api/internal/resolvers"
	"fmt"
	"sync"
	"time"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.Login) (string, error) {
	user, err := resolvers.Authenticate(input.Username, input.Email, input.Password)
	if err != nil {
		return "", err
	}
	token, err := jwt.GenerateToken(user.ID.Hex())
	if err != nil {
		return "", err
	}
	return token, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, oldToken string) (string, error) {
	userId, err := jwt.ParseToken(oldToken)
	if err != nil {
		return "", err
	}
	token, err := jwt.GenerateToken(userId)
	if err != nil {
		return "", err
	}
	return token, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, newUser model.NewUser) (*model.User, error) {
	user := resolvers.MapToUser(newUser)
	_, err := app.App.Users.Create(user)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryUser(user), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, updatedUser model.UpdatedUser) (*model.User, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	changingPassword := false
	if updatedUser.OldPassword != nil {
		if !app.App.Users.Authenticate(users.BuildUserInfo(&user.Username, nil), *updatedUser.OldPassword) {
			return nil, fmt.Errorf("old password is incorrect")
		}
		changingPassword = true
	}
	resolvers.UpdateUser(user, updatedUser)
	_, err = app.App.Users.Update(user, changingPassword)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryUser(user), nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, newProject model.NewProject) (*model.Project, error) {
	owner, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	project, err := resolvers.MapToProjectFromNew(newProject, owner.ID)
	if err != nil {
		return nil, err
	}
	_, err = app.App.Projects.Create(project)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryProject(project), nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, updatedProject model.UpdatedProject) (*model.Project, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	project, err := resolvers.ProjectByStrId(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(project, user) {
		return nil, fmt.Errorf("access denied")
	}
	err = resolvers.UpdateProject(project, updatedProject)
	if err != nil {
		return nil, err
	}
	_, err = app.App.Projects.Update(project.ID, project)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryProject(project), nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return false, err
	}
	project, err := resolvers.ProjectByStrId(id)
	if err != nil {
		return false, err
	}
	if !resolvers.IsOwner(project, user) {
		return false, fmt.Errorf("access denied")
	}
	_, err = app.App.Projects.Delete(project.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateNote is the resolver for the createNote field.
func (r *mutationResolver) CreateNote(ctx context.Context, projectID string, note string) (*model.Note, error) {
	panic(fmt.Errorf("not implemented: CreateNote - createNote"))
}

// UpdateNote is the resolver for the updateNote field.
func (r *mutationResolver) UpdateNote(ctx context.Context, id string, note string) (*model.Note, error) {
	panic(fmt.Errorf("not implemented: UpdateNote - updateNote"))
}

// DeleteNote is the resolver for the deleteNote field.
func (r *mutationResolver) DeleteNote(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteNote - deleteNote"))
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, projectID string, task string, deadline *time.Time, priorityLevel string) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: CreateTask - createTask"))
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, task *string, deadline *time.Time, priorityLevel *string, completionStatus *string) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTask - updateTask"))
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTask - deleteTask"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	usersArr, err := app.App.Users.All()
	if err != nil {
		return nil, err
	}
	return utils.MapTo(usersArr, resolvers.MapToQueryUser), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryUser(user), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := resolvers.UserByStrId(id)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryUser(user), nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) (*model.AllProjects, error) {
	needToWaitFor := 3 // AllPublicProjects, ProjectsOwnedByUser, ProjectsCollaboratedOnByUser
	errors := make(chan error, needToWaitFor)
	publicProjectsChan := make(chan []*model.Project)
	ownedProjectsChan := make(chan []*model.Project)
	collaboratedProjectsChan := make(chan []*model.Project)
	go func() {
		fmt.Println("Getting public projects")
		publicProjects, err := resolvers.PublicProjects()
		errors <- err
		if err == nil {
			publicProjectsChan <- publicProjects
		}
	}()
	go func() {
		user, err := resolvers.UserFromContex(ctx)
		if err != nil { //error here means user is not logged in so we can just return public projects
			errors <- nil
			errors <- nil
			ownedProjectsChan <- nil
			collaboratedProjectsChan <- nil
			return
		}
		wg := sync.WaitGroup{}
		wg.Add(2)
		go func() {
			fmt.Println("Getting owned projects")
			ownedProjects, err := resolvers.ProjectsOwnedByUser(user)
			errors <- err
			if err == nil {
				ownedProjectsChan <- ownedProjects
			}
			wg.Done()
		}()
		go func() {
			fmt.Println("Getting collaborated projects")
			collaboratedProjects, err := resolvers.ProjectsCollaboratedByUser(user)
			errors <- err
			if err == nil {
				collaboratedProjectsChan <- collaboratedProjects
			}
			wg.Done()
		}()
		wg.Wait()
	}()
	for ; needToWaitFor > 0; needToWaitFor-- {
		err := <-errors
		if err != nil {
			return nil, err
		}
	}
	return &model.AllProjects{
		Public:       <-publicProjectsChan,
		Owned:        <-ownedProjectsChan,
		Collaborated: <-collaboratedProjectsChan,
	}, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	project, err := resolvers.ProjectByStrId(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanQueryProject(project, user) {
		return nil, fmt.Errorf("access denied")
	}
	return resolvers.MapToQueryProject(project), nil
}

// UserProjectsByID is the resolver for the userProjectsById field.
func (r *queryResolver) UserProjectsByID(ctx context.Context, id string) ([]*model.Project, error) {
	panic(fmt.Errorf("not implemented: UserProjectsByID - userProjectsById"))
}

// NotesByProject is the resolver for the notesByProject field.
func (r *queryResolver) NotesByProject(ctx context.Context, id string) ([]*model.Note, error) {
	project, err := resolvers.ProjectByStrId(id)
	if err != nil {
		return nil, err
	}
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(project, user) {
		return nil, fmt.Errorf("access denied")
	}
	notes, err := app.App.Notes.AllByProjectId(project.ID)
	if err != nil {
		return nil, err
	}
	return utils.MapTo(notes, resolvers.MapToQueryNote), nil
}

// Note is the resolver for the note field.
func (r *queryResolver) Note(ctx context.Context, id string) (*model.Note, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	note, err := resolvers.GetNoteById(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(resolvers.ProjectByObjId(note.ProjectID), user) {
		return nil, fmt.Errorf("access denied")
	}
	return resolvers.MapToQueryNote(note), nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context) ([]*model.Task, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	return resolvers.TasksAssignedToUser(user)
}

// TaskByProject is the resolver for the taskByProject field.
func (r *queryResolver) TaskByProject(ctx context.Context, id string) ([]*model.Task, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	project, err := resolvers.ProjectByStrId(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(project, user) {
		return nil, fmt.Errorf("access denied")
	}
	return resolvers.TasksByProject(project)
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	task, err := resolvers.TaskById(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(resolvers.ProjectByObjId(task.ProjectID), user) {
		return nil, fmt.Errorf("access denied")
	}
	return resolvers.MapToQueryTask(task), nil
}

// CollabRequests is the resolver for the collabRequests field.
func (r *queryResolver) CollabRequests(ctx context.Context) ([]*model.CollabRequest, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	return resolvers.CollabRequestsByUser(user)
}

// CollabRequestsByProject is the resolver for the collabRequestsByProject field.
func (r *queryResolver) CollabRequestsByProject(ctx context.Context, id string) ([]*model.CollabRequest, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	project, err := resolvers.ProjectByStrId(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(project, user) {
		return nil, fmt.Errorf("access denied")
	}
	return resolvers.CollabRequestsByProject(project)
}

// CollabRequest is the resolver for the collabRequest field.
func (r *queryResolver) CollabRequest(ctx context.Context, id string) (*model.CollabRequest, error) {
	user, err := resolvers.UserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	collabRequest, err := resolvers.CollabRequestByStrId(id)
	if err != nil {
		return nil, err
	}
	if !resolvers.CanMutateProject(resolvers.ProjectByObjId(collabRequest.ProjectID), user) {
		return nil, fmt.Errorf("access denied")
	}
	return resolvers.MapToQueryCollabRequest(collabRequest), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
