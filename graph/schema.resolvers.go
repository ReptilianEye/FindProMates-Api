package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43-dev

import (
	"context"
	"example/FindProMates-Api/graph/model"
	"example/FindProMates-Api/internal/app"
	"example/FindProMates-Api/internal/database/users"
	"example/FindProMates-Api/internal/pkg/jwt"
	"example/FindProMates-Api/internal/pkg/utils"
	"example/FindProMates-Api/internal/resolvers"
	"fmt"
	"sync"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	user := resolvers.MapToUser(input)
	_, err := app.App.Users.Create(&user)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryUser(user), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdatedUser) (*model.User, error) {
	user, err := resolvers.GetUserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	changingPassword := false
	if input.OldPassword != nil {
		if !app.App.Users.Authenticate(users.BuildUserInfo(&user.Username, nil), *input.OldPassword) {
			return nil, fmt.Errorf("old password is incorrect")
		}
		changingPassword = true
	}
	resolvers.UpdateUser(user, input)
	_, err = app.App.Users.Update(user, changingPassword)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryUser(*user), nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.NewProject) (*model.Project, error) {
	owner, err := resolvers.GetUserFromContex(ctx)
	if err != nil {
		return nil, err
	}
	project := resolvers.MapToProjectFromNew(input, owner.ID)
	_, err = app.App.Projects.Create(&project)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryProject(project), nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, input model.UpdatedProject) (*model.Project, error) {
	project, err := resolvers.GetProjectById(ctx, id)
	if err != nil {
		return nil, err
	}
	resolvers.UpdateProject(project, input)
	_, err = app.App.Projects.Update(project.ID, project)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryProject(*project), nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	project, err := resolvers.GetProjectById(ctx, id)
	if err != nil {
		return false, err
	}
	_, err = app.App.Projects.Delete(project.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.Login) (string, error) {
	user, err := resolvers.Authenticate(input.Username, input.Email, input.Password)
	if err != nil {
		return "", err
	}
	token, err := jwt.GenerateToken(user.ID.Hex())
	if err != nil {
		return "", err
	}
	return token, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input string) (string, error) {
	userId, err := jwt.ParseToken(input)
	if err != nil {
		return "", err
	}
	token, err := jwt.GenerateToken(userId)
	if err != nil {
		return "", err
	}
	return token, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	usersArr, err := app.App.Users.All()
	if err != nil {
		return nil, err
	}
	return utils.MapTo(usersArr, resolvers.MapToQueryUser), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Me - me"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) (*model.AllProjects, error) {
	needToWaitFor := 1 // AllPublicProjects, ProjectsOwnedByUser, ProjectsCollaboratedOnByUser
	errors := make(chan error, needToWaitFor)
	publicProjectsChan := make(chan []*model.Project)
	ownedProjectsChan := make(chan []*model.Project)
	collaboratedProjectsChan := make(chan []*model.Project)
	go func() {
		fmt.Println("Getting public projects")
		publicProjects, err := resolvers.AllPublicProjects()
		errors <- err
		if err == nil {
			publicProjectsChan <- publicProjects
		}
	}()
	go func() {
		wg := sync.WaitGroup{}
		wg.Add(2)
		user, err := resolvers.GetUserFromContex(ctx)
		if err != nil {
			ownedProjectsChan <- nil
			collaboratedProjectsChan <- nil
			return
		}
		go func() {
			fmt.Println("Getting owned projects")
			userOwnedProjects, err := resolvers.ProjectsOwnedByUser(user)
			errors <- err
			if err == nil {
				ownedProjectsChan <- userOwnedProjects
			}
			wg.Done()
		}()
		go func() {
			fmt.Println("Getting collaborated projects")
			userCollaboratedProjects, err := resolvers.ProjectsCollaboratedOnByUser(user)
			errors <- err
			if err == nil {
				collaboratedProjectsChan <- userCollaboratedProjects
			}
			wg.Done()
		}()
		wg.Wait()
	}()
	for ; needToWaitFor > 0; needToWaitFor-- {
		err := <-errors
		if err != nil {
			return nil, err
		}
	}
	publicProjects := <-publicProjectsChan
	// return &model.Projects{
	// 	Public:       <-publicProjectsChan,
	// 	Owned:        <-ownedProjectsChan,
	// 	Collaborated: <-collaboratedProjectsChan,
	// }, nil
	return &model.AllProjects{
		Public:       publicProjects,
		Owned:        nil,
		Collaborated: nil,
	}, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	project, err := resolvers.GetProjectById(ctx, id)
	if err != nil {
		return nil, err
	}
	return resolvers.MapToQueryProject(*project), nil
}

// UserProjectsByID is the resolver for the userProjectsById field.
func (r *queryResolver) UserProjectsByID(ctx context.Context, id string) ([]*model.Project, error) {
	panic(fmt.Errorf("not implemented: UserProjectsByID - userProjectsById"))
}

// NotesByProject is the resolver for the notesByProject field.
func (r *queryResolver) NotesByProject(ctx context.Context, id string) ([]*model.Note, error) {
	panic(fmt.Errorf("not implemented: NotesByProject - notesByProject"))
}

// Note is the resolver for the note field.
func (r *queryResolver) Note(ctx context.Context, id string) (*model.Note, error) {
	panic(fmt.Errorf("not implemented: Note - note"))
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context) ([]*model.Task, error) {
	panic(fmt.Errorf("not implemented: Tasks - tasks"))
}

// TaskByProject is the resolver for the taskByProject field.
func (r *queryResolver) TaskByProject(ctx context.Context, id string) ([]*model.Task, error) {
	panic(fmt.Errorf("not implemented: TaskByProject - taskByProject"))
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: Task - task"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
